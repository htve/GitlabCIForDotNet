## 
## Gitlab CI for .Net
##
## 作者:黄涛
## 站点:https://github.com/htve/GitlabCIForDotNet

## MSBuild 的默认安装路径
if(!$MsbuildPath) { $MsbuildPath = 'C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools\MSBuild\Current\Bin\amd64\MSBuild.exe' }

## 解决中文乱码
chcp 65001

function GetServers()
{
    $servers = @{
		'192.168.3.20'=@{
			UserName='a\Administrator';
			Password='5!@~g^m@KBCn,5,L';
			Path = 'C:\WebDeployPackages\'+$global:ProjectName;
		};
		'192.168.3.80'=@{
			UserName='a\Administrator';
			Password='6*mDqFWE6An)3}ED';
			Path = 'D:\WebDeployPackages\'+$global:ProjectName;
		};
	};
    return $servers
}

function GetServerSession([string]$IP)
{
    Try
    {
        $servers=GetServers
        if($servers.ContainsKey($IP))
	    {
		    ## 输入用户凭据
		    $defaultCredential = New-Object Management.Automation.PSCredential $servers[$IP].UserName, (ConvertTo-SecureString $servers[$IP].Password -AsPlainText -Force) -ErrorAction Stop
		    Set-Item WSMan:\localhost\Client\TrustedHosts -value $IP -Force
			## 新建远程会话
		    return @{ Path= $servers[$IP].Path;Session = (New-PSSession -ComputerName $IP -Credential $defaultCredential -ErrorAction Stop) }
	    }
	    else
	    {
		    throw "IP Session "+$n+" does not exist."
		    exit 1
	    }
    }
    catch  
    {  
        throw $_.Exception
        exit 1
    }  
}

function GetMsBuildPath([switch] $Use32BitMsBuild)
{
	if($MsbuildPath -eq $null -or $MsbuildPath.Trim() -eq "") {
		$item = Get-ChildItem -Path "C:\Program Files (x86)"  -Include MSBuild.exe -Recurse | Where-Object {$_.DirectoryName.EndsWith("Bin\amd64")}
		$item = $item.VersionInfo | Sort-Object -Property FileVersion -Descending | Select-Object FileName -First 1
		$MsbuildPath = $item.FileName
		if($MsbuildPath) { 
			Write-Host "Searching for MSBuild.exe takes a long time. It is recommended to write the path '$MsbuildPath' to the variable `$MsbuildPath." 
		}
		else {
			throw "Search MSBuild.exe failed"
			exit 1
		}
	}
	
	if($Use32BitMsBuild) { $MsbuildPath = $MsbuildPath -replace "\\amd64","" }
	
	if(!(Test-Path $MsbuildPath -PathType Leaf)) { throw "MsBuild.exe was not found on this system."; exit 1 }

	return $MsbuildPath
}

function TryDotnet()
{
	Try
    {
		$dotnet = dotnet --version
		Write-Host "dotnet version is $dotnet `n"
    }
    catch  
    {  
        throw $_.Exception
	    exit 1
    }
}

function GetFile(
	[parameter(Mandatory=$false)]
    [string]$ProjectName,
	
	[parameter(Mandatory=$false)]
    [string]$ExtensionName)
{
	if(-not [String]::IsNullOrEmpty($ProjectName)){
		$ProjectName = $ProjectName
		if(-not [String]::IsNullOrEmpty($ExtensionName)){
			$ProjectName += $ExtensionName
		}else{
			$ProjectName += ".csproj"
		}
	} else{
		$ProjectName = "*.sln"
	}
	$file = Get-ChildItem -Include $ProjectName -recurse | Select-Object -first 1 | select -expand FullName
	if([String]::IsNullOrEmpty($file)){ 
		Write-Host "$ProjectName file not found"
		exit 1 
	}
	return $file
}

function RestorePackages(
	[parameter(Mandatory=$false)]
    [string]$ProjectName,
	
	[parameter(Mandatory=$false)]
    [switch] $IsCore)
{
	$file = GetFile -ProjectName:$ProjectName
	
	Write-Host "Start Restoring Nuget Packages ...`n"
	
	$sln = GetFile
	if($IsCore)
	{
		TryDotnet
		$result = dotnet restore $sln
	}
    else
    {
		$nugetPath=$global:FilePath+"\NuGet\nuget.exe"
		if(!(Test-Path $nugetPath -PathType Leaf)) { throw "Path $nugetPath does not exist"; exit 1 }
		$result = .$nugetPath restore $sln
	}
	Write-Host "Restore Nuget Packages To Completed`n"
    return $file
}

function InvokeBuild (
	[parameter(Mandatory=$false,HelpMessage="The path to the file to build (e.g. a .csproj file. Generated by default .sln file).")]
    [string]$ProjectName,
	
    [parameter(Mandatory=$false)]
    [switch] $Use32BitMsBuild,
	
	[parameter(Mandatory=$false)]
    [switch] $IsCore,
	
	[parameter(Mandatory=$false)]
    [string]$Framework,
	
	[parameter(Mandatory=$false)]
    [string]$Runtime,
	
    [parameter(Mandatory=$false)]
    [string] $Configuration="Release",
	
	[parameter(Mandatory=$false)]
    [string] $PublishProfile
    )
{
    Try
    {
		$file = RestorePackages -ProjectName:$ProjectName -IsCore:$IsCore 

		if($IsCore)
		{
			InvokeDotnetBuild -Path:$file -Framework:$Framework -Runtime:$Runtime -Configuration:$Configuration
		}
		else
		{
			InvokeMsBuild -Path:$file -Use32BitMsBuild:$Use32BitMsBuild -Configuration:$Configuration -PublishProfile:$PublishProfile
		}
    }
    catch  
    {  
        throw $_.Exception
	    exit 1
    }  
}

function InvokeMsBuild(
    [Parameter(Position=0,Mandatory = $true)]
    [Alias("Path")]
    [string]$ProjectPath,

    [parameter(Mandatory=$false)]
    [switch] $Use32BitMsBuild,

    [parameter(Mandatory=$false)]
    [string] $Configuration,
	
	[parameter(Mandatory=$false)]
    [string] $PublishProfile
    )
{   
    $build= GetMsBuildPath -Use32BitMsBuild:$Use32BitMsBuild
    Write-Host "MsBuild Path: $build`n"

    Write-Host "Start Build ...`n"
	if([String]::IsNullOrEmpty($PublishProfile)){
      $result = ."$build" $projectPath /p:RunCodeAnalysis=false /consoleloggerparameters:ErrorsOnly /p:Configuration=$Configuration /nologo /verbosity:quiet /maxcpucount 
	}
	else{
	  $result = ."$build" $projectPath /p:RunCodeAnalysis=false /consoleloggerparameters:ErrorsOnly /p:Configuration=$Configuration /nologo /verbosity:quiet /maxcpucount /p:DeployOnBuild=true /p:publishUrl=$global:CiProjectPath/DeployArtifacts /p:PublishProfile=$PublishProfile
	}
	if($result.length -gt 0)
	{ 
		Write-Output $result
		exit 1
	}
    Write-Host "Build To Completed`n"
    return
}

function InvokeDotnetBuild(
    [Parameter(Position=0,Mandatory = $true)]
    [Alias("Path")]
    [string]$ProjectPath,
	
	[parameter(Mandatory=$false)]
    [string]$Framework,
	
	[parameter(Mandatory=$false)]
    [string]$Runtime,
	
	[parameter(Mandatory=$false)]
    [string] $Configuration
)
{
	$configuration="--configuration:"+$Configuration

    $framework='' 
    if($Framework){ $framework="--framework:$Framework"}

    $runtime=''
    if($Runtime){ $runtime="--runtime:$Runtime"}

    dotnet build $configuration $framework $runtime --no-restore --output $global:CiProjectPath/BuildArtifacts --verbosity m $ProjectPath
}

function Test(
	[parameter(Mandatory=$true,HelpMessage="The path to the file to build (e.g. a .csproj file. Generated by default .sln file).")]
    [string]$TestProjectName,
	
	[parameter(Mandatory=$false)]
    [switch] $IsCore)
{
	Try
    {
		$testFile = GetFile -ProjectName:$TestProjectName -ExtensionName:'.dll' 
		
		Write-Host "Start Tests ...`n"
		$test=''
		if($IsCore){ 
			$dotnetPath=(get-command dotnet).source
			$test = ."$global:FilePath\\dotCover\\dotCover.exe" analyse /TargetExecutable="$dotnetPath" /TargetArguments="test $testFile" /Output="Coverage.json" /ReportType="JSON" /Filters="$global:CoverFilters"
		}else{
			$test = ."$global:FilePath\\dotCover\\dotCover.exe" analyse /TargetExecutable="$global:FilePath\\xUnitRunner\\xunit.console.exe" /TargetArguments="$testFile" /Output="Coverage.json" /ReportType="JSON" /Filters="$global:CoverFilters"
		}
		Write-Output $test
		if($test[-5].Contains("Analysed application exited with code")){ exit 1 }
		Write-Host "Tests To Completed`n"

		$CoveragePercent = (Get-Content Coverage.json -TotalCount 6)[-1]
		Write-Host $CoveragePercent
		return
	}
    catch  
    {  
        throw $_.Exception
	    exit 1
    } 
}

function BuildUnpack (
	[parameter(Mandatory=$false,HelpMessage="The path to the file to build (e.g. a .csproj file. Generated by default .sln file).")]
    [string]$ProjectName,
	
	[parameter(Mandatory=$false)]
    [switch] $IsCore,
	
	[parameter(Mandatory=$false)]
    [string]$Framework,
	
	[parameter(Mandatory=$false)]
    [string]$Runtime,
	
	[parameter(Mandatory=$false)]
    [switch] $SelfContained,
	
	[parameter(Mandatory=$false)]
    [string] $PublishProfile)
{
    Try
    {
		$projectPath = RestorePackages -ProjectName:$ProjectName -IsCore:$IsCore
		
		Write-Host "Start Unpack ...`n"
		$Configuration="Release"
		if($IsCore){
            $self_Contained=''
			if($SelfContained) { $self_Contained=' --self-contained'}

            $framework='' 
            if($Framework){ $framework='--framework:$Framework'}

            $runtime=''
            if($Runtime){ $runtime='--runtime:$Runtime'}

            dotnet publish $projectPath --output:$global:CiProjectPath/DeployArtifacts $framework $runtime $self_Contained --configuration:$Configuration --no-restore --verbosity m
		}
		else{
			InvokeBuild -ProjectName $ProjectName -Configuration:$Configuration -PublishProfile:$PublishProfile 
		}
        cd DeployArtifacts
        if (-not (test-path "$env:ProgramFiles\7-Zip\7z.exe")) {throw "$env:ProgramFiles\7-Zip\7z.exe needed"; exit 1} 
        set-alias sz "$env:ProgramFiles\7-Zip\7z.exe" 
        $7z = sz a -t7z -mx=1 "..\$global:CommitId.7z"
        Write-Host "Unpack To Completed`n"
    }
    catch  
    {  
        throw $_.Exception
	    exit 1
    }  
}

function UploadFile ([string]$RemoteIP)
{
    Try
    {
	    $send={
		    param(
			    ## 本地计算机上的路径
			    [Parameter(Mandatory = $true)]
			    [string]$Source,
			
			    ## 远程计算机上的目标路径
			    [Parameter(Mandatory = $true)]
			    [string]$Destination,
			
			    ## session
			    [Parameter(Mandatory = $true)]
			    [System.Management.Automation.Runspaces.PSSession] $Session
		    )
		
		    Set-StrictMode -Version 3
		
		    $remoteScript = {
			    param($destination, $bytes)

			    ## 将目标路径转换为完整的文件系统路径（以支持相对路径）
			    $Destination = $executionContext.SessionState.`
				    Path.GetUnresolvedProviderPathFromPSPath($Destination)

			    ## 将内容写入新文件
			    $file = [IO.File]::Open($Destination, "OpenOrCreate")
			    $null = $file.Seek(0, "End")
			    $null = $file.Write($bytes, 0, $bytes.Length)
			    $file.Close()
		    }

		    $Destination+=('\\'+(Get-Item $Source).Name)
		
		    ## 获取源文件，然后开始读取其内容
		    $sourceFile = Get-Item $source

		    Invoke-Command -Session $session {
			    ## 检测目标文件夹是否存在,不存在则创建
			    if(!(Test-Path $args[0])){md $args[0] -ErrorAction Stop}
			    ## 删除先前存在的文件（如果存在）
			    if(Test-Path $args[0]) { Remove-Item $args[0] }
		    } -ArgumentList $Destination

		    ## 现在把它分成块
		    Write-Progress -Activity "Sending $Source" -Status "Preparing file"

		    $streamSize = 1MB
		    $position = 0
		    $rawBytes = New-Object byte[] $streamSize
		    $file = [IO.File]::OpenRead($sourceFile.FullName)

		    while(($read = $file.Read($rawBytes, 0, $streamSize)) -gt 0)
		    {
			    Write-Progress -Activity "Writing $Destination" `
				    -Status "Sending file" `
				    -PercentComplete ($position / $sourceFile.Length * 100)

			    ## 确保我们的数组与我们从磁盘读取的数据大小相同
			    if($read -ne $rawBytes.Length)
			    {
				    [Array]::Resize( [ref] $rawBytes, $read)
			    }

			    ## 并将该阵列发送到远程系统
			    Invoke-Command -Session $session $remoteScript `
				    -ArgumentList $destination,$rawBytes

			    ## 确保我们的数组与我们从磁盘读取的数据大小相同
			    if($rawBytes.Length -ne $streamSize)
			    {
				    [Array]::Resize( [ref] $rawBytes, $streamSize)
			    }
			
			    [GC]::Collect()
			    $position += $read
		    }

		    $file.Close()

		    ## 显示结果
		    Invoke-Command -Session $session { Get-Item $args[0] } -ArgumentList $Destination
	    }

		$session = GetServerSession $RemoteIP
		Enable-PsRemoting
		Write-Host "Start Uploading To $RemoteIP ...`n"
		$result = Invoke-Command $send -ArgumentList "$global:CommitId.7z",$session.Path,$session.Session
		Write-Host "Uploaded To $RemoteIP`n"
    }
    catch  
    {  
        throw $_.Exception
	    exit 1
    }  
}

function DeployToRemote ([Parameter(Mandatory = $true)][string]$IP,[Parameter(Mandatory = $true)][string]$SiteName)
{
    Try
    {
	    ## 服务器列表
	    $session = GetServerSession $IP

	    $deploy = DeployToLocal
        
        Write-Host "Start Deploy To $IP ...`n"
	    $result = Invoke-Command -Session $session.Session $deploy -ArgumentList ($session.Path+"\$global:CommitId.7z"),$SiteName,$global:Console
        Write-Host "Deployed To $IP`n"
    }
    catch  
    {  
        throw $_.Exception
	    exit 1
    }  
}

function DeployToLocal (
	[Parameter(Mandatory = $false)][string]$File, ##部署包路径
	[Parameter(Mandatory = $true)][string]$SiteName, ##IIS应用名称
	[string]$Console) ##部署后执行文件
{
	Try
    {
		if([String]::IsNullOrEmpty($File)){$File=$global:CommitId+'.7z'}
		Stop-Website $SiteName -ErrorAction Stop
		Stop-WebAppPool $SiteName -ErrorAction Stop
		$IIS_Path="IIS:\Sites\"+$SiteName
		$WEB_PATH = Get-WebFilePath $IIS_Path
		$WEB_PATH_WITH_7Z = "-o"+$WEB_PATH
		."$env:ProgramFiles\7-Zip\7z.exe" x $File $WEB_PATH_WITH_7Z -y
		if(-not [String]::IsNullOrEmpty($Console)){ 
		cd $WEB_PATH
		dotnet $Console -s 
		}
		Start-Website $SiteName -ErrorAction Stop
		Start-WebAppPool $SiteName -ErrorAction Stop
		}
    catch  
    {  
        throw $_.Exception
	    exit 1
    }  
}

Export-ModuleMember -Function InvokeBuild
Export-ModuleMember -Function Test
Export-ModuleMember -Function BuildUnpack
Export-ModuleMember -Function UploadFile
Export-ModuleMember -Function DeployToRemote
Export-ModuleMember -Function DeployToLocal